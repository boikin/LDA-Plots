ggplot2::labs(title = paste(title, lda$lev[i]), color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
print(c)
}
}
lda_posterior_plot(lda=lda2, groups = data2$group, title = "test")
lda_posterior_plot <- function(lda, groups, scale = FALSE, groups.names = NULL,title=NULL, labels = NULL, x.axis = NULL, y.axis = NULL) {
requireNamespace("ggplot2")
requireNamespace("reshape2")
requireNamespace("stringr")
requireNamespace("boot")
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(title)) {
title <- paste("Posterior Probabilities for")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
lda.p <- predict(lda)
V1 <- as.numeric(as.factor(groups))
lda.values <- as.data.frame(cbind(V1, lda.p$x[,1:2]))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x[,1:2])))
}
for (i in seq_along(lda$lev)) {
lda.post <- predict(lda)$posterior
lda.post <- data.frame(lda.values, lda.post[, i])
colnames(lda.post)[4] <- "post"
xgrid <- seq(min(lda.post$LD1), max(lda.post$LD1), (max(lda.post$LD1) - min(lda.post$LD1))/50)
ygrid <- seq(min(lda.post$LD2), max(lda.post$LD2), (max(lda.post$LD2) - min(lda.post$LD2))/50)
grid <- expand.grid(LD1 = xgrid, LD2 = ygrid)
data.loess <- loess(boot::logit((post + 0.001)/1.002) ~ LD1 * LD2 + LD1:LD1 + LD2:LD2, data = lda.post)
lda.3d <- predict(data.loess, newdata = grid)
lda.3d.melt <- reshape2::melt(lda.3d, id.vars = c("LD1", "LD2"), measure.vars = "post")
lda.3d.melt$LD1 <- as.numeric(stringr::str_sub(lda.3d.melt$LD1, stringr::str_locate(lda.3d.melt$LD1, "=")[1, 1] + 1))
lda.3d.melt$LD2 <- as.numeric(stringr::str_sub(lda.3d.melt$LD2, stringr::str_locate(lda.3d.melt$LD2, "=")[1, 1] + 1))
names(lda.3d.melt) <- c("LD1", "LD2", "post")
lda.3d.melt$post <- boot::inv.logit(lda.3d.melt$post)
c <- ggplot2::ggplot(lda.3d.melt, ggplot2::aes(x = LD1, y = LD2, z = post)) +
ggplot2::stat_contour(geom = "polygon") + geom_tile(aes(fill = post)) +
ggplot2::scale_fill_gradient(low = "black", high = "white", name = "posterior") +
ggplot2::geom_point(data = lda.post, aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 2.5) +
ggplot2::labs(title = paste(title, lda$lev[i]), color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
print(c)
}
}
lda_posterior_plot(lda=lda2, groups = data2$group, title = "test")
lda_posterior_plot <- function(lda, groups, scale = FALSE, groups.names = NULL,title=NULL, labels = NULL, x.axis = NULL, y.axis = NULL) {
requireNamespace("ggplot2")
requireNamespace("reshape2")
requireNamespace("stringr")
requireNamespace("boot")
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(title)) {
title <- paste("Posterior Probabilities for")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
lda.p <- predict(lda)
V1 <- as.numeric(as.factor(groups))
lda.values <- as.data.frame(cbind(V1, lda.p$x[,1:2]))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x[,1:2])))
}
for (i in seq_along(lda$lev)) {
lda.post <- predict(lda)$posterior
lda.post <- data.frame(lda.values, lda.post[, i])
colnames(lda.post)[4] <- "post"
xgrid <- seq(min(lda.post$LD1), max(lda.post$LD1), (max(lda.post$LD1) - min(lda.post$LD1))/50)
ygrid <- seq(min(lda.post$LD2), max(lda.post$LD2), (max(lda.post$LD2) - min(lda.post$LD2))/50)
grid <- expand.grid(LD1 = xgrid, LD2 = ygrid)
data.loess <- loess(boot::logit((post + 0.001)/1.002) ~ LD1 * LD2 + LD1:LD1 + LD2:LD2, data = lda.post)
lda.3d <- predict(data.loess, newdata = grid)
lda.3d.melt <- reshape2::melt(lda.3d, id.vars = c("LD1", "LD2"), measure.vars = "post")
lda.3d.melt$LD1 <- as.numeric(stringr::str_sub(lda.3d.melt$LD1, stringr::str_locate(lda.3d.melt$LD1, "=")[1, 1] + 1))
lda.3d.melt$LD2 <- as.numeric(stringr::str_sub(lda.3d.melt$LD2, stringr::str_locate(lda.3d.melt$LD2, "=")[1, 1] + 1))
names(lda.3d.melt) <- c("LD1", "LD2", "post")
lda.3d.melt$post <- boot::inv.logit(lda.3d.melt$post)
c <- ggplot2::ggplot(lda.3d.melt, ggplot2::aes(x = LD1, y = LD2, z = post)) +
ggplot2::stat_contour(geom = "polygon") +
ggplot2::geom_tile(aes(fill = post)) +
ggplot2::scale_fill_gradient(low = "black", high = "white", name = "posterior") +
ggplot2::geom_point(data = lda.post, aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 2.5) +
ggplot2::labs(title = paste(title, lda$lev[i]), color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
print(c)
}
}
lda_posterior_plot(lda=lda2, groups = data2$group, title = "test")
lda_posterior_plot <- function(lda, groups, scale = FALSE, groups.names = NULL,title=NULL, labels = NULL, x.axis = NULL, y.axis = NULL) {
requireNamespace("ggplot2")
requireNamespace("reshape2")
requireNamespace("stringr")
requireNamespace("boot")
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(title)) {
title <- paste("Posterior Probabilities for")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
lda.p <- predict(lda)
V1 <- as.numeric(as.factor(groups))
lda.values <- as.data.frame(cbind(V1, lda.p$x[,1:2]))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x[,1:2])))
}
for (i in seq_along(lda$lev)) {
lda.post <- predict(lda)$posterior
lda.post <- data.frame(lda.values, lda.post[, i])
colnames(lda.post)[4] <- "post"
xgrid <- seq(min(lda.post$LD1), max(lda.post$LD1), (max(lda.post$LD1) - min(lda.post$LD1))/50)
ygrid <- seq(min(lda.post$LD2), max(lda.post$LD2), (max(lda.post$LD2) - min(lda.post$LD2))/50)
grid <- expand.grid(LD1 = xgrid, LD2 = ygrid)
data.loess <- loess(boot::logit((post + 0.001)/1.002) ~ LD1 * LD2 + LD1:LD1 + LD2:LD2, data = lda.post)
lda.3d <- predict(data.loess, newdata = grid)
lda.3d.melt <- reshape2::melt(lda.3d, id.vars = c("LD1", "LD2"), measure.vars = "post")
lda.3d.melt$LD1 <- as.numeric(stringr::str_sub(lda.3d.melt$LD1, stringr::str_locate(lda.3d.melt$LD1, "=")[1, 1] + 1))
lda.3d.melt$LD2 <- as.numeric(stringr::str_sub(lda.3d.melt$LD2, stringr::str_locate(lda.3d.melt$LD2, "=")[1, 1] + 1))
names(lda.3d.melt) <- c("LD1", "LD2", "post")
lda.3d.melt$post <- boot::inv.logit(lda.3d.melt$post)
c <- ggplot2::ggplot(lda.3d.melt, ggplot2::aes(x = LD1, y = LD2, z = post)) +
ggplot2::stat_contour(geom = "polygon") +
ggplot2::geom_tile(ggplot2::aes(fill = post)) +
ggplot2::scale_fill_gradient(low = "black", high = "white", name = "posterior") +
ggplot2::geom_point(data = lda.post, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 2.5) +
ggplot2::labs(title = paste(title, lda$lev[i]), color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
print(c)
}
}
lda_posterior_plot(lda=lda2, groups = data2$group, title = "test")
lda_gplot <- function(lda, groups, alpha = 0.05, N.boot = 101, N.perm = 101, fill = TRUE, means = TRUE, biplot = TRUE, normal.CI = TRUE, circles = FALSE,
boot.CI = FALSE, perm.CI = FALSE, scale = FALSE, groups.names = NULL, labels = NULL, x.axis = NULL, y.axis = NULL, size = 0.1) {
requireNamespace("ggplot2")
requireNamespace("ggforce")
# check null
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
V1 <- as.numeric(as.factor(groups))
lda.vec <- as.data.frame(lda$scaling)
lda.p <- predict(lda)
lda.values <- as.data.frame(cbind(V1, lda.p$x))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x)))
}
g <- length(lda$lev)
mean <- aggregate(. ~ V1, lda.values, FUN = "mean")
n <- lda$counts
N <- lda$N
# base plot
p <- ggplot(lda.values) + ggplot2::geom_point(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 1) + labs(color = groups.names, x = x.axis, y = y.axis) +
scale_color_hue(labels = labels)
# add 95% ci for points
if (normal.CI) {
p <- p + ggplot2::stat_ellipse(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, size = size, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(geom = "polygon", alpha = 0.25, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1), fill = as.factor(V1)), type = "norm",
linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# add mean points
if (means) {
p <- p + ggplot2::geom_point(data = mean, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), shape = 3, size = 3, show.legend = FALSE)
}
# add circles
if (circles) {
p <- p + ggforce::geom_circle(ggplot2::aes(x0 = LD1, y0 = LD2, colour = as.factor(V1), r = sqrt(qchisq(1 - alpha/2, 2)/n)), data = mean, size = size, show.legend = FALSE)
}
# add biplot
if (biplot) {
p <- p + ggplot2::geom_segment(data = lda.vec, ggplot2::aes(x = 0, y = 0, xend = LD1, yend = LD2), arrow = arrow(length = unit(1/2, "picas")), size = size) +
ggplot2::geom_text(data = lda.vec, ggplot2::aes(x = LD1, y = LD2, label = rownames(lda.vec)), hjust = 0, vjust = 0, size = 5)
}
# boot strap CI
if (boot.CI) {
boot <- boot_sample(values = lda.values, N.boot)
p <- p + ggplot2::stat_ellipse(data = boot, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = boot, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# permutation CI
if (perm.CI) {
perm <- perm_sample(values = lda.values, N.perm)
p <- p + ggplot2::stat_ellipse(data = perm, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = perm, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
return(p)
}
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, perm.CI = TRUE, fill = FALSE, scale = TRUE)
p + ggtitle("95% permutation CI's")
p
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, perm.CI = TRUE, fill = FALSE, scale = TRUE)
lda_gplot <- function(lda, groups, alpha = 0.05, N.boot = 101, N.perm = 101, fill = TRUE, means = TRUE, biplot = TRUE, normal.CI = TRUE, circles = FALSE,
boot.CI = FALSE, perm.CI = FALSE, scale = FALSE, groups.names = NULL, labels = NULL, x.axis = NULL, y.axis = NULL, size = 0.1) {
requireNamespace("ggplot2")
requireNamespace("ggforce")
# check null
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
V1 <- as.numeric(as.factor(groups))
lda.vec <- as.data.frame(lda$scaling)
lda.p <- predict(lda)
lda.values <- as.data.frame(cbind(V1, lda.p$x))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x)))
}
g <- length(lda$lev)
mean <- aggregate(. ~ V1, lda.values, FUN = "mean")
n <- lda$counts
N <- lda$N
# base plot
p <- ggplot2::ggplot(lda.values) + ggplot2::geom_point(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 1) + ggplot2::labs(color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
# add 95% ci for points
if (normal.CI) {
p <- p + ggplot2::stat_ellipse(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, size = size, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(geom = "polygon", alpha = 0.25, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1), fill = as.factor(V1)), type = "norm",
linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# add mean points
if (means) {
p <- p + ggplot2::geom_point(data = mean, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), shape = 3, size = 3, show.legend = FALSE)
}
# add circles
if (circles) {
p <- p + ggforce::geom_circle(ggplot2::aes(x0 = LD1, y0 = LD2, colour = as.factor(V1), r = sqrt(qchisq(1 - alpha/2, 2)/n)), data = mean, size = size, show.legend = FALSE)
}
# add biplot
if (biplot) {
p <- p + ggplot2::geom_segment(data = lda.vec, ggplot2::aes(x = 0, y = 0, xend = LD1, yend = LD2), arrow = arrow(length = unit(1/2, "picas")), size = size) +
ggplot2::geom_text(data = lda.vec, ggplot2::aes(x = LD1, y = LD2, label = rownames(lda.vec)), hjust = 0, vjust = 0, size = 5)
}
# boot strap CI
if (boot.CI) {
boot <- boot_sample(values = lda.values, N.boot)
p <- p + ggplot2::stat_ellipse(data = boot, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = boot, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# permutation CI
if (perm.CI) {
perm <- perm_sample(values = lda.values, N.perm)
p <- p + ggplot2::stat_ellipse(data = perm, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = perm, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
return(p)
}
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, perm.CI = TRUE, fill = FALSE, scale = TRUE)
lda_gplot <- function(lda, groups, alpha = 0.05, N.boot = 101, N.perm = 101, fill = TRUE, means = TRUE, biplot = TRUE, normal.CI = TRUE, circles = FALSE,
boot.CI = FALSE, perm.CI = FALSE, scale = FALSE, groups.names = NULL, labels = NULL, x.axis = NULL, y.axis = NULL, size = 0.1) {
requireNamespace("ggplot2")
requireNamespace("ggforce")
# check null
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
V1 <- as.numeric(as.factor(groups))
lda.vec <- as.data.frame(lda$scaling)
lda.p <- predict(lda)
lda.values <- as.data.frame(cbind(V1, lda.p$x))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x)))
}
g <- length(lda$lev)
mean <- aggregate(. ~ V1, lda.values, FUN = "mean")
n <- lda$counts
N <- lda$N
# base plot
p <- ggplot2::ggplot(lda.values) + ggplot2::geom_point(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 1) + ggplot2::labs(color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
# add 95% ci for points
if (normal.CI) {
p <- p + ggplot2::stat_ellipse(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, size = size, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(geom = "polygon", alpha = 0.25, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1), fill = as.factor(V1)), type = "norm",
linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# add mean points
if (means) {
p <- p + ggplot2::geom_point(data = mean, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), shape = 3, size = 3, show.legend = FALSE)
}
# add circles
if (circles) {
p <- p + ggforce::geom_circle(ggplot2::aes(x0 = LD1, y0 = LD2, colour = as.factor(V1), r = sqrt(qchisq(1 - alpha/2, 2)/n)), data = mean, size = size, show.legend = FALSE)
}
# add biplot
if (biplot) {
p <- p + ggplot2::geom_segment(data = lda.vec, ggplot2::aes(x = 0, y = 0, xend = LD1, yend = LD2), arrow = ggplot2::arrow(length = unit(1/2, "picas")), size = size) +
ggplot2::geom_text(data = lda.vec, ggplot2::aes(x = LD1, y = LD2, label = rownames(lda.vec)), hjust = 0, vjust = 0, size = 5)
}
# boot strap CI
if (boot.CI) {
boot <- boot_sample(values = lda.values, N.boot)
p <- p + ggplot2::stat_ellipse(data = boot, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = boot, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# permutation CI
if (perm.CI) {
perm <- perm_sample(values = lda.values, N.perm)
p <- p + ggplot2::stat_ellipse(data = perm, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = perm, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
return(p)
}
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, perm.CI = TRUE, fill = FALSE, scale = TRUE)
?ggplot2::unit
lda_gplot <- function(lda, groups, alpha = 0.05, N.boot = 101, N.perm = 101, fill = TRUE, means = TRUE, biplot = TRUE, normal.CI = TRUE, circles = FALSE,
boot.CI = FALSE, perm.CI = FALSE, scale = FALSE, groups.names = NULL, labels = NULL, x.axis = NULL, y.axis = NULL, size = 0.1) {
requireNamespace("ggplot2")
requireNamespace("ggforce")
# check null
if (is.null(groups.names)) {
groups.names <- c("groups")
}
if (is.null(labels)) {
labels <- as.factor(lda$lev)
}
if (is.null(x.axis)) {
x.axis <- paste("LDA1 ", round(100 * lda$svd[1]^2/sum(lda$svd^2), 1), "%")
}
if (is.null(y.axis)) {
y.axis <- paste("LDA2 ", round(100 * lda$svd[2]^2/sum(lda$svd^2), 1), "%")
}
V1 <- as.numeric(as.factor(groups))
lda.vec <- as.data.frame(lda$scaling)
lda.p <- predict(lda)
lda.values <- as.data.frame(cbind(V1, lda.p$x))
if (scale) {
lda.values <- as.data.frame(cbind(V1, scale(lda.p$x)))
}
g <- length(lda$lev)
mean <- aggregate(. ~ V1, lda.values, FUN = "mean")
n <- lda$counts
N <- lda$N
# base plot
p <- ggplot2::ggplot(lda.values) + ggplot2::geom_point(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), size = 1) + ggplot2::labs(color = groups.names, x = x.axis, y = y.axis) +
ggplot2::scale_color_hue(labels = labels)
# add 95% ci for points
if (normal.CI) {
p <- p + ggplot2::stat_ellipse(ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, size = size, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(geom = "polygon", alpha = 0.25, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1), fill = as.factor(V1)), type = "norm",
linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# add mean points
if (means) {
p <- p + ggplot2::geom_point(data = mean, ggplot2::aes(x = LD1, y = LD2, colour = as.factor(V1)), shape = 3, size = 3, show.legend = FALSE)
}
# add circles
if (circles) {
p <- p + ggforce::geom_circle(ggplot2::aes(x0 = LD1, y0 = LD2, colour = as.factor(V1), r = sqrt(qchisq(1 - alpha/2, 2)/n)), data = mean, size = size, show.legend = FALSE)
}
# add biplot
if (biplot) {
p <- p + ggplot2::geom_segment(data = lda.vec, ggplot2::aes(x = 0, y = 0, xend = LD1, yend = LD2), arrow = ggplot2::arrow(length = ggplot2::unit(1/2, "picas")), size = size) +
ggplot2::geom_text(data = lda.vec, ggplot2::aes(x = LD1, y = LD2, label = rownames(lda.vec)), hjust = 0, vjust = 0, size = 5)
}
# boot strap CI
if (boot.CI) {
boot <- boot_sample(values = lda.values, N.boot)
p <- p + ggplot2::stat_ellipse(data = boot, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = boot, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
# permutation CI
if (perm.CI) {
perm <- perm_sample(values = lda.values, N.perm)
p <- p + ggplot2::stat_ellipse(data = perm, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1)), type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
if (fill) {
p <- p + ggplot2::stat_ellipse(data = perm, geom = "polygon", alpha = 0.25, ggplot2::aes(x = V2, y = V3, colour = as.factor(V1), fill = as.factor(V1)),
type = "norm", linetype = 1, level = 1 - alpha, show.legend = FALSE)
}
}
return(p)
}
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, perm.CI = TRUE, fill = FALSE, scale = TRUE)
p
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, circles = TRUE, fill = FALSE)
p
p<-lda_gplot(lda=iris.lda, groups = iris$Species, normal.CI = FALSE, boot.CI = TRUE, fill = FALSE)
p
?boot_sample
# simulated data set to give random groups
q=100
data <- as.data.frame(list(x1 = runif(q), x2 = rnorm(q), x3 = rlnorm(q), group = sample(c('s','d','w'),q,replace=TRUE)))
# create lda projections, though not needed function will work with any bivariate data and corresponding grouping column
lda <- lda(group ~., data = data)
# format data, groups need to be numeric, can not be factors of characters
V1<-as.numeric(as.factor(data$group))
lda.vec<-as.data.frame(lda$scaling)
lda.p <- predict(lda)
v <- as.data.frame(cbind(V1, lda.p$x))
str(v)
# create bootstrap sample means
b <- boot_sample(values = v)
str(b)
?boot::boot
boot_sample <- function(values, N.b = 100) {
requireNamespace("boot")
G <- max(values$V1)
boot.s <- as.data.frame(array(NA, c(N.b * G, 3)))
statfun = function(d, i) {
colMeans(d[i, ])
}
for (i in 1:G) {
boot.s[N.b * (i - 1) + (1:N.b), 2:3] <- boot::boot(values[values$V1 == i, 2:3], statfun, R = N.b)$t
boot.s[N.b * (i - 1) + (1:N.b), 1] <- i
}
return(boot.s)
}
# simulated data set to give random groups
q=100
data <- as.data.frame(list(x1 = runif(q), x2 = rnorm(q), x3 = rlnorm(q), group = sample(c('s','d','w'),q,replace=TRUE)))
# create lda projections, though not needed function will work with any bivariate data and corresponding grouping column
lda <- lda(group ~., data = data)
# format data, groups need to be numeric, can not be factors of characters
V1<-as.numeric(as.factor(data$group))
lda.vec<-as.data.frame(lda$scaling)
lda.p <- predict(lda)
v <- as.data.frame(cbind(V1, lda.p$x))
str(v)
# create bootstrap sample means
b <- boot_sample(values = v)
str(b)
devtools::document()
devtools::check()
setwd("C:/Users/colee/Downloads/project")
setwd(file.path("C:/Users/colee/Downloads/project", "LDAPlots"))
devtools::document()
devtools::check()
rm(list = c("boot_sample", "lda_gplot", "lda_posterior_plot"))
#usethis::use_vignette("LDAPlots")
devtools::document()
devtools::check()
